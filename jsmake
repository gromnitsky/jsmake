#!/usr/bin/env node

let util = require('util')
let path = require('path')
let fs = require('fs')

let inspect = v => util.inspect(v, {depth:null})

class Location {
    constructor(src, line, col, row) {
	this.src = src || '-'
	this.line = line || -999
	this.col = col
	this.row = row
    }
    toString() {
	return [this.src, this.line, this.col, this.row].
	    filter( v => v !== undefined).join(':')
    }
}

class FToken {
    constructor(location, tag, val) {
	this.tag = tag
	this.val = val
	this.location = location
    }
    inspect() { return [this.location, this.tag, this.val].join('\t') }
}

class FirstTokenizer {
    // input -- a string to tokenize
    // src   -- a file name from which the input came from
    constructor(input, src) {
	this.input = input.split("\n")

	this.tokens = [
	    { type: 'comment', re: '#.*$' },
	    { type: 'recipe',  re: '\t.*$' },
	    { type: 'id', re: '[^=:]+' },
	    { type: 'op',  re: '[=:]'},
	    { type: 'rvalue',  re: '.*$' },
	]
	this.line = 0
	this.src = src
    }

    tokenize() {
	let r = []
	let line_prev = ''
	for (let line of this.input) {
	    this.line++
	    let column = 0
	    if (line.match(/^\s*$/)) continue

	    if (line.match(/\\$/)) { // join lines that end with `\`
		line_prev += line.replace(/\\$/, '')
		continue
	    } else {
		line = line_prev + line
		line_prev = ''
	    }

	    while (line.length) {
		for (let token of this.tokens) {
		    if (!line.length) break

		    let m = line.match(`^${token.re}`)
		    if (!m) continue
		    let skip = m.index + m[0].length
		    line = line.slice(skip)

		    r.push(new FToken(new Location(this.src, this.line,
						   column, column + skip - 1),
				      token.type, m[0].trim()))
		    column += skip
		}
	    }
	}
	return r
    }
}

class Rule {
    constructor(location, target, deps = '', recipes = []) {
	this.location = location
	if (location) {
	    delete this.location.col
	    delete this.location.row
	}
	this.target = target
	this.deps = deps
	this.recipes = recipes
    }
    inspect() {
	return `Rule(${this.location}): ${this.target}: ${this.deps}` +
	    (this.recipes.length ? `\n>>\t${this.recipes.join("\n\t")}` : '')
    }
}

class Var {
    constructor(location, name, value = '') {
	this.location = location
	if (location) {
	    delete this.location.col
	    delete this.location.row
	}
	this.name = name
	this.value = value
    }
    inspect() { return `Var(${this.location}): ${this.name}='${this.value}'` }
}

class Parser {
    constructor(tokens) {
	this.tokens = tokens
	this.vars = {}
	this.rules = []
    }

    parse() {
	let skip = -1
	for (let idx = 0; idx < this.tokens.length; ++idx) {
	    if (skip > idx) continue

	    let cur = this.tokens[idx]
	    let next = this.tokens[idx+1]

	    if (cur.tag === 'id' && next && next.tag === 'op') {
		skip = next.val === '=' ? this.variable(idx) : this.rule(idx)
	    } else if (cur.tag === 'comment') {
		// TODO: annotate the last rule
	    } else {
		throw new Error(`${cur.location}: unexpected ${cur.tag}: ${cur.val}`)
	    }
	}
    }

    rule(idx) {
	let entry = new Rule(this.tokens[idx].location, this.tokens[idx].val)

	idx += 2
	if (this.tokens[idx] && this.tokens[idx].tag === 'rvalue') {
	    entry.deps = this.tokens[idx].val
	    idx++
	}

	let ri = idx
	let recipes = []
	while (this.tokens[ri] && this.tokens[ri].tag === 'recipe') {
	    recipes.push(this.tokens[ri].val)
	    ri++
	}

	if (recipes.length) entry.recipes = recipes
	this.rules.push(entry)

	return ri
    }

    variable(idx) {
	let variable = new Var(this.tokens[idx].location, this.tokens[idx].val)
	this.vars[variable.name] = variable

	idx += 2
	if (this.tokens[idx] && this.tokens[idx].tag !== 'rvalue') return idx

	if (this.tokens[idx])
	    this.vars[variable.name].value = this.tokens[idx].val
	return idx+1
    }
}

let Functions = {
    dir: (names) => {
	return names.split(/\s+/).map( val => {
	    let p = path.dirname(val)
	    return p === '/' ? p : p + '/'
	}).join(' ')
    },
    subst: (from, to, text) => {
	return text.replace(new RegExp(from, 'g'), to)
    }
}

// a tree-like structure for cycles detection in Expander#_expand()
class Worklog {
    constructor(name, parent) {
	this.name = name
	this.parent = parent
    }
    ascendant_of(name) {
        let parent = this.parent
        while (parent) {
            if (parent.name === name) return true
            parent = parent.parent
        }
        return false
    }
    inspect() { return `#<EVar ${this.name} ${inspect(this.parent)}>` }
}

class Expander {
    constructor(parser, functions) {
	this.parser = parser
	this.functions = functions || {}

	this.input = null
	this.tok = null
	this.location = new Location()
    }

    log(msg) { console.error(`${this.location}:`, msg) }

    advance() {
	if (!this.input.length) return this.tok = null // end of input

	let lexems = [
		/^[^$()]+/,
		/^./
	]
	for (let val of lexems) {
	    let m = this.input.match(val)
	    if (m) {
		this.tok = m[0]
		this.input = this.input.slice(m[0].length)
		return this.tok
	    }
	}
	throw new Error(`lexer failure: ${this.input}`)
    }

    // push STR back on input
    pushback(str) { this.input = str + this.input }

    parse(variable) {
	if (!(variable instanceof Var)) throw new Error('Expander#parse()')

	this.input = variable.value
	if (variable.location) this.location = variable.location
	let r = []

	this.advance()
	while (this.tok !== null) {
	    if (this.tok === '$') r.push(this.func())
	    else {
		r.push({ val: this.tok })
		this.advance()
	    }
	}
	return r
    }

    eat(expected_token) {
	if (this.tok !== expected_token)
	    throw new Error(`${this.location}: saw '${this.tok}', expected '${expected_token}'`)
	this.advance()
    }

    func() {
	let result = (val) => ({ type: '$', val})
	let r = []

	this.eat('$')

	let single_char = this.tok[0] // $@, $<, etc
	if (/[^$()]/.test(single_char) && (!this.tok[1] || /\s/.test(this.tok[1]))) {
	    this.pushback(this.tok.slice(1))
	    this.advance()
	    return result([single_char])
	}

	this.eat('(')

	if (this.tok === ')') {
	    this.advance()
	    this.log('an attempt to expand empty space')
	    return result([])
	}

	while (this.tok !== ')') {
	    if (this.tok === null)
		throw new Error(`${this.location}: expected ')'`)

	    if (this.tok === '$') r.push(this.func())
	    else {
		r.push(this.tok)
		this.advance()
	    }
	}

	this.eat(')')
	return result(r)
    }

    // rewrites this.parser.{vars,rules} with expanded values
    expand() {
	this.expand_vars()
	this.expand_rules()
    }

    expand_vars() {
	let e_vars = {}
	for (let key in this.parser.vars) {
	    let variable = this.parser.vars[key]

	    let e_key = this._expand(this.parse(new Var(variable.location, 'dummy1', key)))
	    // the value of the macro (the right-side, after the '=')
	    // is expanded when (a) the macro is requested during
	    // recipe execution, or (b) if it's mentioned in the
	    // left-size part (before the '='), or (c) when target lines
	    // are being expanded.
	    //
	    // i.e., we're NOT doing it here!
	    e_vars[e_key] = new Var(variable.location, e_key, variable.value)
	}
	this.parser.vars = e_vars
    }

    expand_rules() {
	let e_rules = []
	for (let rule of this.parser.rules) {
	    let e_target = this._expand(this.parse(new Var(rule.location, 'dummy2', rule.target)))
	    let entry = new Rule(rule.location, e_target)
	    if (rule.deps) entry.deps = this._expand(this.parse(new Var(null, 'dummy3', rule.deps)))
	    if (rule.recipes) {
	    	// rules are being expanded during the invocation, not here
	    	entry.recipes = rule.recipes
	    }
	    e_rules.push(entry)
	}
	this.parser.rules = e_rules
    }

    // crazy recursive
    _expand(arr, worklog) {
	return arr.map( item => {
	    // a non-expandable portion
	    if (item.type !== '$') return (item.val || item)

	    // turtles all the way down
	    let r = this._expand(item.val, worklog)
	    let defined = this.parser.vars[r]
	    // the value of the variable we've found can be expanded too
	    if (defined) {
		if (worklog && worklog.ascendant_of(r))
		    throw new Error(`${this.location}: var '${r}' references itself`)
		return this._expand(this.parse(defined), new Worklog(r, worklog))
	    }

	    // check r in the list of known functions; TODO: refactor out
	    let fname = r.split(' ')[0]
	    if (fname in this.functions) {
		// remove the leading spaces only for the 1st arg
		// before passing them all to the function
		let fargs = r.split(' ').slice(1).join(' ').
		    trimLeft().split(',')
		return this.functions[fname].apply(this, fargs)
	    }

	    // check r in the environment
	    if (r in process.env) return process.env[r]

	    this.log(`undefined variable '${r}'`)
	    return '?'		// FIXME
	}).join('')
    }
}

exports.Var = Var
exports.Rule = Rule
exports.FirstTokenizer = FirstTokenizer
exports.Parser = Parser
exports.Expander = Expander

exports.Functions = Functions

// CLI

let tokenize_file = function(file) {
    let str = fs.readFileSync(file === '-' ? '/dev/stdin' : file).toString()
    return new FirstTokenizer(str, file).tokenize()
}

let err = function(exit_code, ...args) {
    console.error(path.basename(process.argv[1]), 'error:', ...args)
    process.exit(exit_code)
}

// Main
if (process.argv[1] === __filename) {
    let conf = {
	version: '0.0.1',	// meta
	verbose: 0,		// TODO
	touch: false,		// TODO
	dry_run: false,		// TODO
    }

    let makefiles = []
    let targets = []		// TODO
    let user_vars = []

    let skip = 0
    let args = process.argv.slice(2)
    for (let idx=0; idx < args.length; ++idx) {
	if (skip > idx) continue
	let opt = args[idx]

	if (opt === '-f') {
	    if (!args[idx+1]) err(2, '-f requires an argument')
	    makefiles.push(args[idx+1])
	    skip = idx+1	// eat the next arg
	}
	else if (opt === '-d') conf.verbose++
	else if (opt === '-t') conf.touch = true
	else if (opt === '-n') conf.dry_run = true
	else if (opt === '-v') {
	    console.log(conf.version)
	    process.exit(0)
	}
	else if (opt.indexOf('=') !== -1) { // FOO=bar
	    user_vars = user_vars.concat(new FirstTokenizer(opt, 'cmd').tokenize())
	} else targets.push(opt)
    }

    if (!makefiles.length) err(2, 'no makefile found')

    let tokens = [].concat(...makefiles.map( file => tokenize_file(file)))
	.concat(user_vars)
    console.log(tokens)

    let parser = new Parser(tokens)
    parser.parse()
    console.log(parser.vars)
    console.log(parser.rules)

    console.log('')
    let expander = new Expander(parser, Functions)
    expander.expand()
    console.log(parser.vars)
    console.log(parser.rules)
}
