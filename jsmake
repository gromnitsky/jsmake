#!/usr/bin/env node

let util = require('util')
let path = require('path')
let fs = require('fs')

let inspect = v => util.inspect(v, {depth:null})

class Location {
    constructor(src, line, col, row) {
	this.src = src || '-'
	this.line = line || -999
	this.col = col
	this.row = row
    }
    toString() {
	return [this.src, this.line, this.col, this.row].
	    filter( v => v !== undefined).join(':')
    }
}

class FToken {
    constructor(location, tag, val) {
	this.tag = tag
	this.val = val
	this.location = location
    }
    inspect() { return [this.location, this.tag, this.val].join('\t') }
}

class FirstTokenizer {
    // input -- a string to tokenize
    // src   -- a file name from which the input came from
    constructor(input, src) {
	this.input = input.split("\n")

	this.tokens = [
	    { type: 'comment', re: '#.*$' },
	    { type: 'recipe',  re: '\t.*$' },
	    { type: 'id', re: '[^=:]+' },
	    { type: 'op',  re: '[=:]'},
	    { type: 'rvalue',  re: '.*$' },
	]
	this.line = 0
	this.src = src
    }

    tokenize() {
	let r = []
	let line_prev = ''
	for (let line of this.input) {
	    this.line++
	    let column = 0
	    if (line.match(/^\s*$/)) continue

	    if (line.match(/\\$/)) { // join lines that end with `\`
		line_prev += line.replace(/\\$/, '')
		continue
	    } else {
		line = line_prev + line
		line_prev = ''
	    }

	    while (line.length) {
		for (let token of this.tokens) {
		    if (!line.length) break

		    let m = line.match(`^${token.re}`)
		    if (!m) continue
		    let skip = m.index + m[0].length
		    line = line.slice(skip)

		    r.push(new FToken(new Location(this.src, this.line,
						   column, column + skip - 1),
				      token.type, m[0].trim()))
		    column += skip
		}
	    }
	}
	return r
    }
}

class Rule {
    constructor(location, target, deps = '', recipes = []) {
	this.location = location
	if (location) {
	    delete this.location.col
	    delete this.location.row
	}
	this.target = target
	this.deps = deps || ''
	this.recipes = recipes
    }
    inspect() {
	return `Rule(${this.location}): ${this.target}: ${this.deps}` +
	    (this.recipes.length ? `\n>>\t${this.recipes.join("\n\t")}` : '')
    }
}

class Var {
    constructor(location, name, value = '') {
	this.location = location
	if (location) {
	    delete this.location.col
	    delete this.location.row
	}
	this.name = name
	this.value = value
    }
    inspect() { return `Var(${this.location}): ${this.name}='${this.value}'` }
}

class Parser {
    constructor(tokens) {
	this.tokens = tokens
	this.vars = {}
	this.rules = []
    }

    parse() {
	let skip = -1
	for (let idx = 0; idx < this.tokens.length; ++idx) {
	    if (skip > idx) continue

	    let cur = this.tokens[idx]
	    let next = this.tokens[idx+1]

	    if (cur.tag === 'id' && next && next.tag === 'op') {
		skip = next.val === '=' ? this.variable(idx) : this.rule(idx)
	    } else if (cur.tag === 'comment') {
		// TODO: annotate the last rule
	    } else {
		throw new Error(`${cur.location}: unexpected ${cur.tag}: ${cur.val}`)
	    }
	}
    }

    rule(idx) {
	let entry = new Rule(this.tokens[idx].location, this.tokens[idx].val)

	idx += 2
	if (this.tokens[idx] && this.tokens[idx].tag === 'rvalue') {
	    entry.deps = this.tokens[idx].val
	    idx++
	}

	let ri = idx
	let recipes = []
	while (this.tokens[ri] && this.tokens[ri].tag === 'recipe') {
	    recipes.push(this.tokens[ri].val)
	    ri++
	}

	if (recipes.length) entry.recipes = recipes
	this.rules.push(entry)

	return ri
    }

    variable(idx) {
	let variable = new Var(this.tokens[idx].location, this.tokens[idx].val)
	this.vars[variable.name] = variable

	idx += 2
	if (this.tokens[idx] && this.tokens[idx].tag !== 'rvalue') return idx

	if (this.tokens[idx])
	    this.vars[variable.name].value = this.tokens[idx].val
	return idx+1
    }
}

let Functions = {
    dir: (names) => {
	return names.split(/\s+/).map( val => {
	    let p = path.dirname(val)
	    return p === '/' ? p : p + '/'
	}).join(' ')
    },
    subst: (from, to, text) => {
	return text.replace(new RegExp(from, 'g'), to)
    }
}

// a syntax tree node
class STNode {
    constructor(type, val) {
	this.type = type,
	this.val = val
	this.kids = []
    }
    add_kid(node) {
	this.kids.push(node)
	return this
    }
}

class Expander {
    constructor(parser, functions) {
	this.parser = parser
	this.functions = functions || {}

	this.input = null
	this.tok = null
	this.location = new Location()
    }

    log(msg) { console.error(`${this.location}:`, msg) }

    advance() {
	if (!this.input.length) return this.tok = null // end of input

	let lexems = [
		/^[^$()]+/,
		/^./
	]
	for (let val of lexems) {
	    let m = this.input.match(val)
	    if (m) {
		this.tok = m[0]
		this.input = this.input.slice(m[0].length)
		return this.tok
	    }
	}
	throw new Error(`lexer failure: ${this.input}`)
    }

    // push STR back on input
    pushback(str) { this.input = str + this.input }

    parse(variable) {
	if (!(variable instanceof Var)) throw new Error('Expander#parse()')

	this.input = variable.value
	if (variable.location) this.location = variable.location
	let node = new STNode('$')

	this.advance()
	while (this.tok !== null) {
	    if (this.tok === '$') node.add_kid(this.func())
	    else {
		node.add_kid(new STNode('term', this.tok))
		this.advance()
	    }
	}
	return node
    }

    eat(expected_token) {
	if (this.tok !== expected_token)
	    throw new Error(`${this.location}: saw '${this.tok}', expected '${expected_token}'`)
	this.advance()
    }

    func() {
	this.eat('$')

	let single_char = this.tok[0] // $@, $<, etc
	if (/[^$()]/.test(single_char) && (!this.tok[1] || /\s/.test(this.tok[1]))) {
	    this.pushback(this.tok.slice(1))
	    this.advance()
	    return new STNode('$').add_kid(new STNode('term', single_char))
	}

	this.eat('(')

	if (this.tok === ')') {
	    this.advance()
	    this.log('an attempt to expand empty space')
	    return new STNode('term', '')
	}

	let node = new STNode('$')
	while (this.tok !== ')') {
	    if (this.tok === null)
		throw new Error(`${this.location}: expected ')'`)

	    if (this.tok === '$') node.add_kid(this.func())
	    else {
		node.add_kid(new STNode('term', this.tok))
		this.advance()
	    }
	}

	this.eat(')')
	return node
    }

    // rewrites this.parser.{vars,rules} with expanded values
    expand() {
	this.expand_vars()
	this.expand_rules()
    }

    expand_vars() {
	let e_vars = {}
	for (let key in this.parser.vars) {
	    let variable = this.parser.vars[key]

	    let e_key = this._expand(this.parse(new Var(variable.location, 'dummy1', key)))
	    // the value of the macro (the right-side, after the '=')
	    // is expanded when (a) the macro is requested during
	    // recipe execution, or (b) if it's mentioned in the
	    // left-size part (before the '='), or (c) when target lines
	    // are being expanded.
	    //
	    // i.e., we're NOT doing it here!
	    e_vars[e_key] = new Var(variable.location, e_key, variable.value)
	}
	this.parser.vars = e_vars
    }

    expand_rules() {
	let e_rules = this.parser.rules.map( rule => {
	    let e_target = this._expand(this.parse(new Var(rule.location, 'dummy2', rule.target)))
	    let entry = new Rule(rule.location, e_target)
	    if (rule.deps) entry.deps = this._expand(this.parse(new Var(null, 'dummy3', rule.deps)))
	    if (rule.recipes) {
	    	// rules are being expanded during the invocation, not here
	    	entry.recipes = rule.recipes
	    }
	    return entry
	})
	this.parser.rules = e_rules
    }

    // STR is a function name with args; check if the func name in the
    // list of known functions & if it is, run it
    func_run(str) {
	let fname = str.split(' ')[0]
	if (fname in this.functions) {
	    // remove the leading spaces only for the 1st arg
	    // before passing them all to the function
	    let fargs = str.split(' ').slice(1).join(' ').
	    	trimLeft().split(',')
	    return this.functions[fname].apply(this, fargs)
	}
	// return undefined if no valid func name was in STR
    }

    _expand(node, _start) {
	if (node.type === '$') {
	    return node.kids.map( kid => {
		if (kid.type === 'term') return kid.val

		// turtles all the way down
		let estr = this._expand(kid)
		let variable = this.parser.vars[estr]
		if (variable) {
		    // the value of the variable we've found can be
		    // expanded too!
		    if (_start === estr) throw new Error(`${this.location}: var '${estr}' references itself`)
		    return this._expand(this.parse(variable), _start || estr)
		}

		let funcall = this.func_run(estr)
		if (funcall !== undefined) return funcall

		// check the environment
		if (estr in process.env) return process.env[estr]

		this.log(`undefined variable '${estr}'`)
		return '?'	// FIXME

	    }).join('')
	} else {
	    return node.val
	}
    }
}

exports.Var = Var
exports.Rule = Rule
exports.FirstTokenizer = FirstTokenizer
exports.Parser = Parser
exports.Expander = Expander

exports.Functions = Functions

let str2list = function(str) {
    return [...new Set(str.split(/\s+/))]
}

class Maker {
    constructor(expanded_rules, goals) {
	this.rules_raw = expanded_rules
	this.rules = {
	    normal: [],
	    implicit: []
	}
	this.goals = goals
    }

    log(rule, msg) { console.error(`${rule.location}:`, msg) }

    default_goal() {
	return this.goals[0] || (this.rules.normal && this.rules.normal[0].target)
    }

    normalize() {
	this.rules_raw.forEach( rule => {
	    str2list(rule.target).forEach( target => {
		if (rule.target.indexOf('%') !== -1) {
		    // TODO
		} else {
		    // normal rules
		    let prev_idx = this.rules.normal.findIndex( val => val.target === target)
		    let prev_deps = []
		    if (prev_idx !== -1) {
			this.log(rule, `overriding recipe for target '${target}', ${this.rules.normal[prev_idx].location}`)
			// save the deps & rm the old entry
			prev_deps = this.rules.normal[prev_idx].deps
			this.rules.normal.splice(prev_idx, 1)
		    }
		    let deps = [...new Set(prev_deps.concat(str2list(rule.deps)))]
		    this.rules.normal.push(new Rule(rule.location, target, deps, rule.recipes))
		}
	    })
	})
    }
}

// CLI

let tokenize_file = function(file) {
    let str = fs.readFileSync(file === '-' ? '/dev/stdin' : file).toString()
    return new FirstTokenizer(str, file).tokenize()
}

let err = function(exit_code, ...args) {
    console.error(path.basename(process.argv[1]), 'error:', ...args)
    process.exit(exit_code)
}

// Main
if (process.argv[1] === __filename) {
    let conf = {
	version: '0.0.1',	// meta
	verbose: 0,		// TODO
	touch: false,		// TODO
	dry_run: false,		// TODO
    }

    let makefiles = []
    let goals = []		// TODO
    let user_vars = []

    let skip = -1
    let args = process.argv.slice(2)
    for (let idx=0; idx < args.length; ++idx) {
	if (skip >= idx) continue
	let opt = args[idx]

	if (opt === '-f') {
	    if (!args[idx+1]) err(2, '-f requires an argument')
	    makefiles.push(args[idx+1])
	    skip = idx+1	// eat the next arg
	}
	else if (opt === '-d') conf.verbose++
	else if (opt === '-t') conf.touch = true
	else if (opt === '-n') conf.dry_run = true
	else if (opt === '-v') {
	    console.log(conf.version)
	    process.exit(0)
	}
	else if (opt.indexOf('=') !== -1) { // FOO=bar
	    user_vars = user_vars.concat(new FirstTokenizer(opt, 'cmd').tokenize())
	} else goals.push(opt)
    }

    if (!makefiles.length) err(2, 'no makefile found')

    let tokens = [].concat(...makefiles.map( file => tokenize_file(file)))
	.concat(user_vars)
    if (conf.verbose) console.log(tokens)

    let parser = new Parser(tokens)
    parser.parse()
    if (conf.verbose) {
	console.log(parser.vars)
	console.log(parser.rules)
	console.log('')
    }

    let expander = new Expander(parser, Functions)
    expander.expand()
    if (conf.verbose) {
	console.log(parser.vars)
	console.log(parser.rules)
	console.log('')
    }

    let maker = new Maker(parser.rules, goals)
    maker.normalize()
    console.log(maker.rules)
    console.log('DEFAULT GOAL:', maker.default_goal())
}
